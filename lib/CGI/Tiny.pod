=pod

=encoding UTF-8

=head1 NAME

CGI::Tiny - Common Gateway Interface, with no frills

=head1 SYNOPSIS

  #!/usr/bin/perl
  use strict;
  use warnings;
  use utf8;
  use CGI::Tiny;

  cgi {
    my $cgi = $_;
    $cgi->set_error_handler(sub {
      my ($cgi, $error, $rendered) = @_;
      warn $error;
      unless ($rendered) {
        if ($cgi->response_status_code == 413) {
          $cgi->render(json => {error => 'Request body limit exceeded'});
        } elsif ($cgi->response_status_code == 400) {
          $cgi->render(json => {error => 'Bad request'});
        } else {
          $cgi->render(json => {error => 'Internal server error'});
        }
      }
    });

    my $method = $cgi->method;
    my $fribble;
    if ($method eq 'GET') {
      $fribble = $cgi->query_param('fribble');
    } elsif ($method eq 'POST') {
      $fribble = $cgi->body_param('fribble');
    } else {
      $cgi->set_response_status(405)->render;
      exit;
    }
    die "Invalid fribble parameter" unless length $fribble;

    if ($cgi->query_param('download')) {
      $cgi->set_response_disposition(attachment => 'fribble.json');
    }
    $cgi->render(json => {fribble => $fribble});
  };

=head1 DESCRIPTION

CGI::Tiny provides a modern interface to write
L<CGI|https://en.wikipedia.org/wiki/Common_Gateway_Interface> scripts to
dynamically respond to HTTP requests as defined in
L<RFC 3875|https://tools.ietf.org/html/rfc3875>. It is intended to be:

=over

=item * Minimal

CGI::Tiny contains a small amount of code and (on modern Perls) no non-core
requirements. No framework needed.

=item * Simple

CGI::Tiny is straightforward to use, avoids anything magical or surprising, and
provides easy access to the most commonly needed features.

=item * Robust

CGI::Tiny's interface is designed to help the developer avoid common pitfalls
and vulnerabilities by default.

=item * Lazy

CGI::Tiny only loads code or processes information once it is needed, so simple
requests can be handled without unnecessary overhead.

=item * Restrained

CGI::Tiny is designed for the CGI protocol which executes the program again for
every request. It is not suitable for persistent protocols like FastCGI or
PSGI.

=item * Flexible

CGI::Tiny can be used with other modules to handle tasks like routing and
templating, and doesn't impose unnecessary constraints to reading input or
rendering output.

=back

Most applications are better written in a L<PSGI>-compatible framework (e.g.
L<Dancer2> or L<Mojolicious>) and deployed in a persistent application server
so that the application does not have to start up again every time it receives
a request. CGI::Tiny, and the CGI protocol in general, is only suited for
restricted deployment environments that can only run CGI scripts, or
applications that don't need to scale.

See L</"COMPARISON TO CGI.PM">.

This module's interface is currently I<EXPERIMENTAL> and may be changed
incompatibly if needed.

=head1 USAGE

=for Pod::Coverage cgi

CGI::Tiny's interface is a regular function called C<cgi> exported by default.

  use CGI::Tiny;
  cgi {
    my $cgi = $_;
    # set up error handling on $cgi
    # inspect request data via $cgi
    # set response headers if needed via $cgi
    # render response data with $cgi->render or $cgi->render_chunk
  };

The code block is immediately run with C<$_> set to a CGI::Tiny object, which
L</"METHODS"> can be called on to read request information and render a
response.

If an exception is thrown within the code block, or the code block does not
render a response, it will run the handler set by L</"set_error_handler"> if
any, or by default emit the error as a warning and (if nothing has been
rendered yet) render a 500 Internal Server Error. The default server error
will also be rendered if the process ends abnormally between importing from
CGI::Tiny and the start of the C<cgi> block.

Note that the C<cgi> block's current implementation as a regular exported
subroutine is an implementation detail, and future implementations reserve the
right to provide it as an XSUB or keyword for performance reasons. You should
not rely on C<@_> to be set, and you should not use C<return> to exit the
block; use C<exit> to end a CGI script early after rendering a response.

=head1 EXTENDING

CGI::Tiny is a minimal interface to the CGI protocol, but can be extended with
the use of other CPAN modules.

=head2 Fatpacking

L<App::FatPacker> can be used to pack CGI::Tiny, as well as any other pure-perl
dependencies, into a CGI script so that it can be deployed to other systems
without having to install the dependencies there. As a bonus, this means the
script doesn't have to load those modules separately from disk on every
execution.

Just keep in mind that the script will have to be repacked to update those
dependencies, and CGI scripts greatly benefit from efficient XS tools which
cannot be packed this way.

  $ fatpack pack script.source.cgi > script.cgi

To pack in optional modules, such as JSON support for Perls older than 5.14:

  $ fatpack trace --use=JSON::PP script.source.cgi
  $ fatpack packlists-for $(cat fatpacker.trace) > packlists
  $ fatpack tree $(cat packlists)
  $ fatpack file script.source.cgi > script.cgi

=head2 JSON

CGI::Tiny has built in support for parsing and rendering JSON content with
L<JSON::PP>. CGI scripts that deal with JSON content will greatly benefit from
installing L<Cpanel::JSON::XS> version C<4.09> or newer for efficient encoding
and decoding, which will be used automatically if available.

=head2 Templating

HTML and XML responses are most easily managed with templating. A number of
CPAN modules provide this capability.

L<Text::Xslate> is an efficient template engine designed for HTML/XML.

  #!/usr/bin/perl
  use strict;
  use warnings;
  use utf8;
  use CGI::Tiny;
  use Text::Xslate;
  use Data::Section::Simple 'get_data_section';

  cgi {
    my $cgi = $_;
    my $foo = $cgi->query_param('foo');
    my $tx = Text::Xslate->new(path => ['templates'], cache => 0);

    # from templates/
    $cgi->render(html => $tx->render('index.tx', {foo => $foo}));

    # or from __DATA__
    my $template = get_data_section 'index.tx';
    $cgi->render(html => $tx->render_string($template, {foo => $foo}));
  };

  __DATA__
  @@ index.tx
  <html><body><h1><: $foo :></h1></body></html>

L<Mojo::Template> is a lightweight HTML/XML template engine in the L<Mojo>
toolkit.

  #!/usr/bin/perl
  use strict;
  use warnings;
  use utf8;
  use CGI::Tiny;
  use Mojo::Template;
  use Mojo::File 'curfile';
  use Mojo::Loader 'data_section';

  cgi {
    my $cgi = $_;
    my $foo = $cgi->query_param('foo');
    my $mt = Mojo::Template->new(auto_escape => 1, vars => 1);

    # from templates/
    my $template_path = curfile->sibling('templates', 'index.html.ep');
    $cgi->render(html => $mt->render_file($template_path, {foo => $foo}));

    # or from __DATA__
    my $template = data_section __PACKAGE__, 'index.html.ep';
    $cgi->render(html => $mt->render($template, {foo => $foo}));
  };

  __DATA__
  @@ index.html.ep
  <html><body><h1><%= $foo %></h1></body></html>

=head2 Files

Modules like L<Path::Tiny> and L<MIME::Types> can help with file responses. Be
aware that Perl and some operating systems work with filenames in encoded
bytes (usually UTF-8), but this module works with parameters in Unicode
characters, so non-ASCII filenames make things trickier.

  #!/usr/bin/perl
  use strict;
  use warnings;
  use utf8;
  use CGI::Tiny;
  use Path::Tiny;
  use MIME::Types;
  use Unicode::UTF8 qw(encode_utf8 decode_utf8);

  cgi {
    my $cgi = $_;

    my $filename = $cgi->query_param('filename');
    unless (length $filename) {
      $cgi->set_response_status(404)->render(text => 'Not Found');
      exit;
    }

    # get files from public/ next to cgi-bin/
    my $public_dir = path(__FILE__)->realpath->parent->sibling('public');
    my $encoded_filename = encode_utf8 $filename;
    my $filepath = $public_dir->child($encoded_filename);

    # ensure file exists, is readable, and is not a directory
    unless (-r $filepath and !-d _) {
      $cgi->set_response_status(404)->render(text => 'Not Found');
      exit;
    }

    # ensure file path doesn't escape the public/ directory
    unless ($public_dir->subsumes($filepath->realpath)) {
      $cgi->set_response_status(404)->render(text => 'Not Found');
      exit;
    }

    my $basename = decode_utf8 $filepath->basename;
    my $mime = MIME::Types->new->mimeTypeOf($basename);
    $cgi->set_response_type($mime->type) if defined $mime;
    $cgi->set_response_disposition(attachment => $basename)->render(file => $filepath);
  };

=head2 Logging

CGI scripts can usually log errors directly to STDERR with the C<warn>
function, and rely on the CGI server to log them to a file, but you will likely
need to encode errors to UTF-8 if you expect them to contain non-ASCII text.

Minimal loggers like L<Log::Any> can also be used to redirect errors and
warnings to a file or other logging mechanism specific to the CGI script,
encode them to bytes automatically, and also log debugging information when the
log level is set to C<debug>. Just make sure the CGI server has permission to
create and write to the logging target.

  #!/usr/bin/perl
  use strict;
  use warnings;
  use utf8;
  use CGI::Tiny;
  use Log::Any;
  use Log::Any::Adapter
    {category => 'cgi-script'}, # only log our category here
    File => '/path/to/log/file.log',
    binmode => ':encoding(UTF-8)',
    log_level => $ENV{MY_CGI_LOG_LEVEL} || 'info';

  my $log = Log::Any->get_logger(category => 'cgi-script');

  local $SIG{__WARN__} = sub {
    my ($warning) = @_;
    chomp $warning;
    $log->warn($warning);
  };

  cgi {
    my $cgi = $_;

    $cgi->set_error_handler(sub {
      my ($cgi, $error, $rendered) = @_;
      chomp $error;
      $log->error($error);
    });

    # only logged if MY_CGI_LOG_LEVEL=debug set in CGI server environment
    $log->debugf('Method: %s, Path: %s, Query: %s', $cgi->method, $cgi->path, $cgi->query);

    # handle the actual request
  };

=head2 Routing

Web applications use routing to serve multiple types of requests from one
application. L<Routes::Tiny> can be used to organize this with CGI::Tiny, using
C<REQUEST_METHOD> and C<PATH_INFO> (which is the URL path after the CGI script
name).

  #!/usr/bin/perl
  use strict;
  use warnings;
  use utf8;
  use CGI::Tiny;
  use Routes::Tiny;

  my %dispatch = (
    foos => sub {
      my ($cgi) = @_;
      my $method = $cgi->method;
      ...
    },
    get_foo => sub {
      my ($cgi, $captures) = @_;
      my $id = $captures->{id};
      ...
    },
    put_foo => sub {
      my ($cgi, $captures) = @_;
      my $id = $captures->{id};
      ...
    },
  );

  cgi {
    my $cgi = $_;

    my $routes = Routes::Tiny->new;
    # /script.cgi/foo
    $routes->add_route('/foo', name => 'foos');
    # /script.cgi/foo/42
    $routes->add_route('/foo/:id', method => 'GET', name => 'get_foo');
    $routes->add_route('/foo/:id', method => 'PUT', name => 'put_foo');

    if (defined(my $match = $routes->match($cgi->path, method => $cgi->method))) {
      $dispatch{$match->name}->($cgi, $match->captures);
    } else {
      $cgi->set_response_status(404)->render(text => 'Not Found');
    }
  };

=head1 METHODS

The following methods can be called on the CGI::Tiny object provided to the
C<cgi> code block.

=head2 Setup

=head3 set_error_handler

  $cgi = $cgi->set_error_handler(sub {
    my ($cgi, $error, $rendered) = @_;
    ...
  });

Sets an error handler to run in the event of an exception or if the script ends
without rendering a response. The handler will be called with the CGI::Tiny
object, the error value, and a boolean indicating whether response headers have
been rendered yet.

The error value can be any exception thrown by Perl or user code. It should
generally not be included in any response rendered to the client, but instead
warned or logged.

Exceptions may occur before or after response headers have been rendered. If
response headers have not been rendered, error handlers may inspect
L</"response_status_code"> and/or render some error response. The response
status code may be set to a specific error status by some errors, and will
default to 500 when this handler is called if it has not been set to a 400- or
500-level error status.

If the error handler itself throws an exception, that error and the original
error will be emitted as a warning. If no response has been rendered after the
error handler completes or dies, a default error response will be rendered.

Note that the error handler is only meant for logging and customization of the
final error response in a failed request dispatch; to handle exceptions within
standard application flow without causing an error response, use an exception
handling mechanism such as L<Syntax::Keyword::Try> or L<Feature::Compat::Try>
(which will use the new C<try> feature if available).

=head3 set_request_body_buffer

  $cgi = $cgi->set_request_body_buffer(256*1024);

Sets the buffer size (number of bytes to read at once) for reading the request
body. Defaults to the value of the C<CGI_TINY_REQUEST_BODY_BUFFER> environment
variable or 262144 (256 KiB). A value of 0 will use the default value.

=head3 set_request_body_limit

  $cgi = $cgi->set_request_body_limit(16*1024*1024);

Sets the limit in bytes for the request body. Defaults to the value of the
C<CGI_TINY_REQUEST_BODY_LIMIT> environment variable or 16777216 (16 MiB). A
value of 0 will remove the limit (not recommended unless you have other
safeguards on memory usage).

Since the request body is not parsed until needed, methods that parse the
request body like L</"body"> or L</"upload"> will set the response status to
C<413 Payload Too Large> and throw an exception if the content length is over
the limit. Files uploaded through a C<multipartE<sol>form-data> request body
also count toward this limit, though they are streamed to temporary files when
parsed.

=head3 set_multipart_form_charset

  $cgi = $cgi->set_multipart_form_charset('UTF-8');

Sets the default charset for decoding C<multipartE<sol>form-data> forms,
defaults to C<UTF-8>. Parameter and upload field names, upload filenames, and
text parameter values that don't specify a charset will be decoded from this
charset. Set to an empty string to disable this decoding, effectively
interpreting such values in C<ISO-8859-1>.

=head3 set_input_handle

  $cgi = $cgi->set_input_handle($fh);

Sets the input handle to read the request body from. If not set, reads from
C<STDIN>. The handle will have C<binmode> applied before reading to remove any
translation layers.

=head3 set_output_handle

  $cgi = $cgi->set_output_handle($fh);

Sets the output handle to print the response to. If not set, prints to
C<STDOUT>. The handle will have C<binmode> applied before printing to remove
any translation layers.

=head2 Request Environment

=head3 auth_type

=head3 content_length

=head3 content_type

=head3 gateway_interface

=head3 path_info

=head3 path_translated

=head3 query_string

=head3 remote_addr

=head3 remote_host

=head3 remote_ident

=head3 remote_user

=head3 request_method

=head3 script_name

=head3 server_name

=head3 server_port

=head3 server_protocol

=head3 server_software

  my $auth_type      = $cgi->auth_type;         # AUTH_TYPE
  my $content_length = $cgi->content_length;    # CONTENT_LENGTH
  my $content_type   = $cgi->content_type;      # CONTENT_TYPE
  my $gateway        = $cgi->gateway_interface; # GATEWAY_INTERFACE
  my $path           = $cgi->path_info;         # PATH_INFO
  my $file_path      = $cgi->path_translated;   # PATH_TRANSLATED
  my $query          = $cgi->query_string;      # QUERY_STRING
  my $remote_addr    = $cgi->remote_addr;       # REMOTE_ADDR
  my $remote_host    = $cgi->remote_host;       # REMOTE_HOST
  my $remote_ident   = $cgi->remote_ident;      # REMOTE_IDENT
  my $remote_user    = $cgi->remote_user;       # REMOTE_USER
  my $method         = $cgi->request_method;    # REQUEST_METHOD
  my $script_name    = $cgi->script_name;       # SCRIPT_NAME
  my $hostname       = $cgi->server_name;       # SERVER_NAME
  my $port           = $cgi->server_port;       # SERVER_PORT
  my $protocol       = $cgi->server_protocol;   # SERVER_PROTOCOL
  my $server         = $cgi->server_software;   # SERVER_SOFTWARE

Access to L<request meta-variables|https://tools.ietf.org/html/rfc3875#section-4.1>
of the equivalent uppercase names. Since CGI does not distinguish between
missing and empty values, missing values will be normalized to an empty string.

=head3 method

=head3 path

=head3 query

  my $method = $cgi->method; # REQUEST_METHOD
  my $path   = $cgi->path;   # PATH_INFO
  my $query  = $cgi->query;  # QUERY_STRING

Short aliases for a few request meta-variables.

=head2 Request Parsing

=head3 query_params

  my $pairs = $cgi->query_params;

Retrieve URL query string parameters as an ordered array reference of
name/value pairs, represented as two-element array references. Names and values
are decoded to Unicode characters.

=head3 query_param_names

  my $arrayref = $cgi->query_param_names;

Retrieve URL query string parameter names, decoded to Unicode characters, as an
ordered array reference.

=head3 query_param

  my $value = $cgi->query_param('foo');

Retrieve value of a named URL query string parameter, decoded to Unicode
characters. If the parameter name was passed multiple times, returns the last
value. Use L</"query_param_array"> to get multiple values of a parameter.

=head3 query_param_array

  my $arrayref = $cgi->query_param_array('foo');

Retrieve values of a named URL query string parameter, decoded to Unicode
characters, as an ordered array reference.

=head3 headers

  my $hashref = $cgi->headers;

Hash reference of available request header names and values. Header names are
represented in lowercase.

=head3 header

  my $value = $cgi->header('Accept-Language');

Retrieve the value of a request header by name (case insensitive). CGI request
headers can only contain a single value, which may be combined from multiple
values.

=head3 cookies

  my $pairs = $cgi->cookies;

Retrieve request cookies as an ordered array reference of name/value pairs,
represented as two-element array references.

=head3 cookie_names

  my $arrayref = $cgi->cookie_names;

Retrieve request cookie names as an ordered array reference.

=head3 cookie

  my $value = $cgi->cookie('foo');

Retrieve the value of a request cookie by name. If multiple cookies were passed
with the same name, returns the last value. Use L</"cookie_array"> to get
multiple values of a cookie name.

=head3 cookie_array

  my $arrayref = $cgi->cookie_array('foo');

Retrieve values of a request cookie name as an ordered array reference.

=head3 body

  my $bytes = $cgi->body;

Retrieve the request body as bytes.

Note that this will read the whole request body into memory, so make sure the
L</"set_request_body_limit"> can fit well within the available memory.

Not available after calling L</"body_parts">, L</"body_params">, or
L</"uploads"> (or related accessors) on a C<multipartE<sol>form-data> request,
since this type of request body is not retained in memory after parsing.

=head3 body_params

  my $pairs = $cgi->body_params;

Retrieve C<applicationE<sol>x-www-form-urlencoded> or
C<multipartE<sol>form-data> body parameters as an ordered array reference of
name/value pairs, represented as two-element array references. Names and values
are decoded to Unicode characters.

Note that this will read the text form fields into memory, so make sure the
L</"set_request_body_limit"> can fit well within the available memory.

=head3 body_param_names

  my $arrayref = $cgi->body_param_names;

Retrieve C<applicationE<sol>x-www-form-urlencoded> or
C<multipartE<sol>form-data> body parameter names, decoded to Unicode
characters, as an ordered array reference.

Note that this will read the text form fields into memory, so make sure the
L</"set_request_body_limit"> can fit well within the available memory.

=head3 body_param

  my $value = $cgi->body_param('foo');

Retrieve value of a named C<applicationE<sol>x-www-form-urlencoded> or
C<multipartE<sol>form-data> body parameter, decoded to Unicode characters. If
the parameter name was passed multiple times, returns the last value. Use
L</"body_param_array"> to get multiple values of a parameter.

Note that this will read the text form fields into memory, so make sure the
L</"set_request_body_limit"> can fit well within the available memory.

=head3 body_param_array

  my $arrayref = $cgi->body_param_array('foo');

Retrieve values of a named C<applicationE<sol>x-www-form-urlencoded> or
C<multipartE<sol>form-data> body parameter, decoded to Unicode characters, as
an ordered array reference.

Note that this will read the text form fields into memory, so make sure the
L</"set_request_body_limit"> can fit well within the available memory.

=head3 body_json

  my $data = $cgi->body_json;

Decode an C<application/json> request body from UTF-8-encoded JSON.

Note that this will read the whole request body into memory, so make sure the
L</"set_request_body_limit"> can fit well within the available memory.

=head3 body_parts

  my $parts = $cgi->body_parts;

Retrieve C<multipartE<sol>form-data> request body parts as an ordered array
reference. Most applications should retrieve multipart form data through
L</"body_params"> and L</"uploads"> (or related accessors) instead.

Note that this will read the text form fields into memory, so make sure the
L</"set_request_body_limit"> can fit well within the available memory.

Body parts are represented as hash references containing:

=over

=item headers

Hash reference of part headers. Header names are represented in lowercase.

=item name

Form field name from C<Content-Disposition> header, undecoded.

=item filename

Filename from C<Content-Disposition> header if present, undecoded.

=item size

Size of part contents in bytes.

=item content

Part contents as undecoded bytes, for parts without a defined C<filename>. File
uploads are stored in a temporary C<file> instead.

=item file

L<File::Temp> object referencing temporary file containing the part contents,
for parts with a defined C<filename>.

=back

=head3 uploads

  my $pairs = $cgi->uploads;

Retrieve C<multipartE<sol>form-data> file uploads as an ordered array reference
of name/upload pairs, represented as two-element array references. Names are
decoded to Unicode characters.

Note that this will read the text form fields into memory, so make sure the
L</"set_request_body_limit"> can fit well within the available memory.

File uploads are represented as a hash reference containing the following keys:

=over

=item filename

Original filename supplied to file input. An empty filename may indicate that
no file was submitted.

=item content_type

C<Content-Type> of uploaded file, undef if unspecified.

=item size

File size in bytes.

=item file

L<File::Temp> object storing the file contents in a temporary file, which will
be cleaned up when the CGI script ends by default. The filehandle will be open
with the C<seek> pointer at the start of the file for reading.

=back

=head3 upload_names

  my $arrayref = $cgi->upload_names;

Retrieve C<multipartE<sol>form-data> file upload names, decoded to Unicode
characters, as an ordered array reference.

Note that this will read the text form fields into memory, so make sure the
L</"set_request_body_limit"> can fit well within the available memory.

=head3 upload

  my $upload = $cgi->upload('foo');

Retrieve a named C<multipartE<sol>form-data> file upload. If the upload name
was passed multiple times, returns the last value. Use L</"upload_array">
to get multiple uploads with the same name.

See L</"uploads"> for details on the representation of the upload.

Note that this will read the text form fields into memory, so make sure the
L</"set_request_body_limit"> can fit well within the available memory.

=head3 upload_array

  my $arrayref = $cgi->upload_array('foo');

Retrieve all C<multipartE<sol>form-data> file uploads of the specified name as
an ordered array reference.

See L</"uploads"> for details on the representation of the uploads.

Note that this will read the text form fields into memory, so make sure the
L</"set_request_body_limit"> can fit well within the available memory.

=head2 Response

=head3 set_nph

  $cgi = $cgi->set_nph;
  $cgi = $cgi->set_nph(1);

If set to a true value or called without a value before rendering response
headers, CGI::Tiny will act as a
L<NPH (Non-Parsed Header)|https://tools.ietf.org/html/rfc3875#section-5> script
and render full HTTP response headers. This may be required for some CGI
servers, or enable unbuffered responses or HTTP extensions not supported by the
CGI server.

No effect after response headers have been rendered.

=head3 set_response_body_buffer

  $cgi = $cgi->set_response_body_buffer(128*1024);

Sets the buffer size (number of bytes to read at once) for streaming a C<file>
or C<handle> response body with L</"render"> or L</"render_chunk">. Defaults to
the value of the C<CGI_TINY_RESPONSE_BODY_BUFFER> environment variable or
131072 (128 KiB). A value of 0 will use the default value.

=head3 set_response_status

  $cgi = $cgi->set_response_status(404);
  $cgi = $cgi->set_response_status('500 Internal Server Error');

Sets the response HTTP status code. A full status string including a
human-readable message will be used as-is. A bare status code must be a known
L<HTTP status code|https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml>
and will have the standard human-readable message appended.

No effect after response headers have been rendered.

The CGI protocol assumes a status of C<200 OK> if no response status is set.

=head3 set_response_disposition

  $cgi = $cgi->set_response_disposition('attachment');
  $cgi = $cgi->set_response_disposition(attachment => $filename);
  $cgi = $cgi->set_response_disposition('inline'); # default behavior
  $cgi = $cgi->set_response_disposition(inline => $filename);

Sets the response C<Content-Disposition> header to indicate how the client
should present the response, with an optional filename specified in Unicode
characters. C<attachment> suggests to download the content as a file, and
C<inline> suggests to display the content inline (the default behavior). No
effect after response headers have been rendered.

=head3 set_response_type

  $cgi = $cgi->set_response_type('application/xml');

Sets the response C<Content-Type> header, to override autodetection in
L</"render"> or L</"render_chunk">. C<undef> will remove the override. No
effect after response headers have been rendered.

=head3 set_response_charset

  $cgi = $cgi->set_response_charset('UTF-8');

Set charset to use when rendering C<text>, C<html>, or C<xml> response data,
defaults to C<UTF-8>.

=head3 add_response_header

  $cgi = $cgi->add_response_header('Content-Language' => 'en');

Adds a custom response header. No effect after response headers have been
rendered.

Note that header names are case insensitive and CGI::Tiny does not attempt to
deduplicate or munge headers that have been added manually. Headers are printed
in the response in the same order added, and adding the same header multiple
times will result in multiple instances of that response header.

=head3 add_response_cookie

  $cgi = $cgi->add_response_cookie($name => $value,
    Expires   => 'Sun, 06 Nov 1994 08:49:37 GMT',
    HttpOnly  => 1,
    'Max-Age' => 3600,
    Path      => '/foo',
    SameSite  => 'Strict',
    Secure    => 1,
  );

Adds a C<Set-Cookie> response header. No effect after response headers have
been rendered.

Note that cookie values should only consist of ASCII characters and may not
contain any control characters, space characters, or the characters C<",;\>.
More complex values can be encoded to UTF-8 and L<base64|MIME::Base64> for
transport.

  use Unicode::UTF8 'encode_utf8';
  use MIME::Base64 'encode_base64';
  my $encoded_value = encode_base64 encode_utf8($value), '';
  $cgi->add_response_cookie(foo => $encoded_value, %attrs);

  use Unicode::UTF8 'decode_utf8';
  use MIME::Base64 'decode_base64';
  my $value = decode_utf8 decode_base64 $cgi->cookie('foo');

Data structures can be encoded to JSON and base64 for transport.

  use Cpanel::JSON::XS 'encode_json';
  use MIME::Base64 'encode_base64';
  my $encoded_value = encode_base64 encode_json(\%hash), '';
  $cgi->add_response_cookie(foo => $encoded_value, %attrs);

  use Cpanel::JSON::XS 'decode_json';
  use MIME::Base64 'decode_base64';
  my $hashref = decode_json decode_base64 $cgi->cookie('foo');

Optional cookie attributes are specified in key-value pairs after the cookie
name and value. Cookie attribute names are case-insensitive.

=over

=item Domain

Domain for which cookie is valid.

=item Expires

Expiration date string for cookie. L</"epoch_to_date"> can be used to generate
the appropriate date string format.

=item HttpOnly

If set to a true value, the cookie will be restricted from client-side scripts.

=item Max-Age

Max age of cookie before it expires, in seconds, as an alternative to
specifying C<Expires>.

=item Path

URL path for which cookie is valid.

=item SameSite

C<Strict> to restrict the cookie to requests from the same site, C<Lax> to
allow it additionally in certain cross-site requests. This attribute is
currently part of a draft specification so its handling may change, but it is
supported by most browsers.

=item Secure

If set to a true value, the cookie will be restricted to HTTPS requests.

=back

=head3 reset_response_headers

  $cgi = $cgi->reset_response_headers;

Remove any pending response headers set by L</"add_response_header"> or
L</"add_response_cookie">. No effect after response headers have been rendered.

=head3 response_status_code

  my $code = $cgi->response_status_code;

Numerical response HTTP status code that will be sent when headers are
rendered, as set by L</"set_response_status"> or an error occurring. Defaults
to C<200>.

=head3 render

  $cgi = $cgi->render;
  $cgi = $cgi->render(html     => $html);
  $cgi = $cgi->render(xml      => $xml);
  $cgi = $cgi->render(text     => $text);
  $cgi = $cgi->render(data     => $bytes);
  $cgi = $cgi->render(file     => $filepath);
  $cgi = $cgi->render(json     => $ref);
  $cgi = $cgi->render(redirect => $url);

Renders response headers and then fixed-length response data of a type
indicated by the first parameter, if any. A C<Content-Length> header will be
set to the length of the encoded response content, and further calls to
C<render> or L</"render_chunk"> will throw an exception. Use L</"render_chunk">
instead to render without a C<Content-Length> header.

The C<Content-Type> response header will be set according to
L</"set_response_type">, or autodetected depending on the data type passed, or
to C<application/octet-stream> if there is no more appropriate value.

The C<Date> response header will be set to the current time as an HTTP date
string if not set manually.

C<html>, C<xml>, or C<text> data is expected to be decoded Unicode characters,
and will be encoded according to L</"set_response_charset"> (UTF-8 by default).
L<Unicode::UTF8> will be used for efficient UTF-8 encoding if available.

C<data> or C<file> will render bytes from a string or local file path
respectively. A C<handle>, or a C<file> whose size cannot be determined
accurately from the filesystem, must be rendered using L</"render_chunk"> since
its C<Content-Length> cannot be determined beforehand.

C<json> data structures will be encoded to JSON and UTF-8.

C<redirect> will set a C<Location> header if response headers have not yet been
rendered, and will set a response status of 302 unless a different 300-level
status has been set with L</"set_response_status">. It will set a
C<Content-Length> of 0, and it will not set a C<Content-Type> response header.

=head3 render_chunk

  $cgi = $cgi->render_chunk;
  $cgi = $cgi->render_chunk(html   => $html);
  $cgi = $cgi->render_chunk(xml    => $xml);
  $cgi = $cgi->render_chunk(text   => $text);
  $cgi = $cgi->render_chunk(data   => $bytes);
  $cgi = $cgi->render_chunk(file   => $filepath);
  $cgi = $cgi->render_chunk(handle => $filehandle);
  $cgi = $cgi->render_chunk(json   => $ref);

Renders response headers the first time it is called, and then chunked response
data of a type indicated by the first parameter, if any. No C<Content-Length>
header will be set, and C<render_chunk> may be called additional times with
more response data.

C<render_chunk> does not impose a chunked response, it simply does not generate
a C<Content-Length> header. For content where the total encoded content length
is known in advance but the content can't be passed to a single L</"render">
call, a C<Content-Length> header can be set manually with
L</"add_response_header">, and then C<render_chunk> may be used to render each
part.

The C<Content-Type> response header will be set according to
L</"set_response_type">, or autodetected depending on the data type passed in
the first call to C<render_chunk>, or to C<application/octet-stream> if there
is no more appropriate value.

The C<Date> response header will be set to the current time as an HTTP date
string if not set manually.

C<html>, C<xml>, or C<text> data is expected to be decoded Unicode characters,
and will be encoded according to L</"set_response_charset"> (UTF-8 by default).
L<Unicode::UTF8> will be used for efficient UTF-8 encoding if available.

C<data>, C<file>, or C<handle> will render bytes from a string, local file
path, or open filehandle respectively. A C<handle> will have C<binmode> applied
to remove any translation layers, and its contents will be streamed until EOF.

C<json> data structures will be encoded to JSON and UTF-8.

C<redirect> responses must be rendered with L</"render">.

=head1 FUNCTIONS

The following convenience functions are provided but not exported.

=head2 epoch_to_date

  my $date = CGI::Tiny::epoch_to_date $epoch;

Convert a Unix epoch timestamp, such as returned by C<time>, to a RFC 1123 HTTP
date string suitable for use in HTTP headers such as C<Date> and C<Expires>.

=head2 date_to_epoch

  my $epoch = CGI::Tiny::date_to_epoch $date;

Parse a RFC 1123 HTTP date string to a Unix epoch timestamp. For compatibility
as required by L<RFC 7231|https://tools.ietf.org/html/rfc7231#section-7.1.1.1>,
legacy RFC 850 and ANSI C asctime date formats are also recognized. Returns
C<undef> if the string does not parse as any of these formats.

  # RFC 1123
  my $epoch = CGI::Tiny::date_to_epoch 'Sun, 06 Nov 1994 08:49:37 GMT';

  # RFC 850
  my $epoch = CGI::Tiny::date_to_epoch 'Sunday, 06-Nov-94 08:49:37 GMT';

  # asctime
  my $epoch = CGI::Tiny::date_to_epoch 'Sun Nov  6 08:49:37 1994';

=head1 ENVIRONMENT

CGI::Tiny recognizes the following environment variables, in addition to the
standard CGI environment variables.

=head2 CGI_TINY_REQUEST_BODY_BUFFER

Default value for L</"set_request_body_buffer">.

=head2 CGI_TINY_REQUEST_BODY_LIMIT

Default value for L</"set_request_body_limit">.

=head2 CGI_TINY_RESPONSE_BODY_BUFFER

Default value for L</"set_response_body_buffer">.

=head1 COMPARISON TO CGI.PM

Traditionally, the L<CGI> module (referred to as CGI.pm to differentiate it
from the CGI protocol) has been used to write Perl CGI scripts. This module
fills a similar need but has a number of interface differences to be aware of.

=over

=item *

There is no CGI::Tiny object constructor; the object is accessible within the
C<cgi> block, only reads request data from the environment once it is accessed,
and ensures that a valid response is rendered to avoid gateway errors even in
the event of an exception or premature exit.

=item *

Instead of global variables like C<$CGI::POST_MAX>, global behavior settings
are applied to the CGI::Tiny object inside the C<cgi> block.

=item *

Exceptions within the C<cgi> block are handled by default by rendering a server
error response and emitting the error as a warning. This can be customized with
L</"set_error_handler">.

=item *

Request query and body parameter accessors in CGI::Tiny are not context
sensitive, as context sensitivity can lead to surprising behavior and
L<vulnerabilities|https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1572>.
L</"query_param">, L</"body_param">, and L</"upload"> always return a single
value; L</"query_param_array">, L</"body_param_array">, and L</"upload_array">
must be used to retrieve multi-value parameters.

=item *

CGI::Tiny does not have a method-sensitive C<param> accessor; query and body
request parameters are accessed with L</"query_param"> and L</"body_param">
respectively. Uploaded files and their metadata are accessed with L</"upload">
and do not affect the text parameter accessors.

=item *

CGI::Tiny decodes request query and body parameters to Unicode characters
automatically, and L</"render">/L</"render_chunk"> provide methods to encode
response data from Unicode characters to UTF-8 by default.

=item *

In CGI.pm, response headers must be printed manually before any response data
is printed to avoid malformed responses. In CGI::Tiny, the L</"render"> or
L</"render_chunk"> methods are used to print response data, and automatically
print response headers when first called. C<redirect> responses are also
handled by L</"render">.

=item *

In CGI::Tiny, a custom response status is set by calling
L</"set_response_status"> before the first L</"render"> or L</"render_chunk">,
which only requires the status code and will add the appropriate human-readable
status message itself.

=item *

Response setters are distinct methods from request accessors in CGI::Tiny.
L</"content_type">, L</"header">, and L</"cookie"> are used to access request
data, and L</"set_response_type">, L</"add_response_header">, and
L</"add_response_cookie"> are used to set response headers for the pending
response before the first call to L</"render"> or L</"render_chunk">.

=item *

CGI::Tiny does not provide any HTML generation helpers, as this functionality
is much better implemented by other robust implementations on CPAN; see
L</"Templating">.

=item *

CGI::Tiny does not do any implicit encoding of cookie values or the C<Expires>
header or cookie attribute. The L</"epoch_to_date"> convenience function is
provided to render appropriate C<Expires> date values.

=back

There are a number of alternatives to CGI.pm but they do not sufficiently
address the design issues; primarily, none of them gracefully handle
exceptions or failure to render a response, and several of them have no
features for rendering responses.

=over

=item *

L<CGI::Simple> shares all of the interface design problems of CGI.pm, though it
does not reimplement the HTML generation helpers.

=item *

L<CGI::Thin> is ancient and only implements parsing of request query or body
parameters, without decoding them to Unicode characters.

=item *

L<CGI::Minimal> has context-sensitive parameter accessors, and only implements
parsing of request query/body parameters (without decoding them to Unicode
characters) and uploads.

=item *

L<CGI::Lite> has context-sensitive parameter accessors, and only implements
parsing of request query/body parameters (without decoding them to Unicode
characters), uploads, and cookies.

=item *

L<CGI::Easy> has a robust interface, but pre-parses all request information.

=back

=head1 CAVEATS

CGI is an extremely simplistic protocol and relies particularly on the global
state of environment variables and the C<STDIN> and C<STDOUT> standard
filehandles. CGI::Tiny does not prevent you from messing with these interfaces
directly, but it may result in confusion.

CGI::Tiny eschews certain sanity checking for performance reasons. For example,
C<Content-Type> and other header values set for the response should only
contain ASCII text with no control characters, but CGI::Tiny does not verify
this (though it does verify they do not contain newline characters to protect
against HTTP response splitting).

Field names and filenames in C<multipartE<sol>form-data> requests do not have
a well-defined escape mechanism for special characters, so CGI::Tiny will not
attempt to decode these names from however the client passes them aside from
L</"set_multipart_form_charset">. For best compatibility, form field names
should be ASCII without double quotes or semicolons.

=head1 TODO

=over

=item * Debugging tools

=back

=head1 BUGS

Report any issues on the public bugtracker.

=head1 AUTHOR

Dan Book <dbook@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is Copyright (c) 2021 by Dan Book.

This is free software, licensed under:

  The Artistic License 2.0 (GPL Compatible)

=head1 SEE ALSO

L<CGI::Alternatives>, L<Mojolicious>, L<Dancer2>
